# GENERATE_SERIES Function

SQL Server 2022 introduces the `GENERATE_SERIES` function, a powerful tool that simplifies the generation of sequences of numbers, including integer and decimal series, as well as date and time ranges. This function eliminates the need for complex workarounds like recursive CTEs or auxiliary number tables for sequence generation.

Start by pressing `CTRL+N` to open a new query window for this lab in SSMS. Then switch to the AdventureWorks2019 database:

```sql
USE AdventureWorks2019
```

## Transition from Recursive CTEs to GENERATE_SERIES

Previously, we might have used recursive CTEs for this:

```sql
WITH GenerateSeriesCte(value) AS 
(
    SELECT 1 UNION ALL 
    SELECT value + 1 FROM GenerateSeriesCte WHERE value < 1000
)
SELECT value = value FROM GenerateSeriesCte
OPTION (MAXRECURSION 1000)
```

Using recursive CTEs to generate sequences can be verbose and inefficient, especially for larger sequences. The new `GENERATE_SERIES` function in SQL Server 2022 offers a better approach.

First, the database compatibility level needs to be set to 160 (SQL Server 2022) to utilize `GENERATE_SERIES`, but the `AdventureWorks2019` database compatibility level is 140 (it was created for SQL Server 2017). Use the `ALTER DATABASE` statement to raise the database compatibility level to 160:

```sql
-- The AdventureWorks2019 database compatibility level is 140 (SQL Server 2017)
SELECT compatibility_level FROM sys.databases WHERE name = 'AdventureWorks2019'

-- Raise the compatibility level to 160 (SQL Server 2022)
ALTER DATABASE AdventureWorks2019 SET COMPATIBILITY_LEVEL = 160
```

Now we can use the new `GENERATE_SERIES` function to easily generate a simple range of numbers. For example, from 1 to 10:

```sql
SELECT value
FROM GENERATE_SERIES(1, 10)
```

Or, create a series with a step value, from 1 to 50, stepping by 5:

```sql
SELECT value
FROM GENERATE_SERIES(1, 50, 5)
```

Or, generating a decimal series from 0.0 to 1.0 with a step of 0.1, using parameterized values:

```sql
DECLARE @start decimal(2, 1) = 0.0
DECLARE @stop decimal(2, 1) = 1.0
DECLARE @step decimal(2, 1) = 0.1
    
SELECT value
FROM GENERATE_SERIES(@start, @stop, @step)
```

## Creating a Date Series

This code shows how to generate a series of dates using the `GENERATE_SERIES` function in SQL Server, which natively generates a sequence of numbers. Since `GENERATE_SERIES` does not directly support date generation, the `DATEDIFF` and `DATEADD` functions can be leveraged to achieve this.

```sql
DECLARE @StartOn date = '2023-02-05'
DECLARE @EndOn date = '2023-11-15'
    
DECLARE @DayCount int = DATEDIFF(DAY, @StartOn, @EndOn)
    
SELECT
  TheDate = DATEADD(DAY, value, @StartOn)
FROM
  GENERATE_SERIES(0, @DayCount)
```

This query generates a date series ranging from 2/5/2023 to 11/15/2023 using the following steps:

**1. Determine the Number of Days**: The `DATEDIFF` function calculates the total number of days between two dates, `@StartOn` and `@EndOn`. This duration, stored in `@DayCount`, represents the total number of days to generate in the series.

**2. Generate a Numeric Series**: `GENERATE_SERIES(0, @DayCount)` generates a series of integers starting from 0 up to `@DayCount`. Each number in this series represents an incremental day from the start date.

**3. Convert Numbers to Dates**: For each integer value generated by `GENERATE_SERIES`, the `DATEADD` function adds that value as days to the `@StartOn` date. This effectively converts the numeric series into a series of dates, starting from `@StartOn` and ending on `@EndOn`.

By combining these steps, the code effectively produces a sequence of dates, one for each day within the specified range. This approach leverages the `GENERATE_SERIES` function's capability to produce a sequence of integers and uses date functions to map those integers to corresponding dates.

## Scenario: Reporting on Sales Data with Unpopulated Intervals

Consider a scenario where sales data is recorded at various times throughout a day. For example, a car dealership sells cars throughout the day. When reporting hourly sales, there's certainly no guarantee that at least one car was sold every hour. Traditional aggregation methods like `GROUP BY` will omit hours with no sales, potentially skewing analysis or reporting.

### Step 1: Setup Sales Data Table

First, we create and populate a `Sales` table with sample sales data:

```sql
CREATE TABLE Sales
(
    OrderDateTime    datetime,
    Total            decimal(12,2)
)

-- Populate sales data, where some hours have no sales
INSERT Sales
 (OrderDateTime,        Total) VALUES
 ('2022-05-01 09:35',   21000),
 ('2022-05-01 09:47',   30000),
 ('2022-05-01 11:35',   23000),
 ('2022-05-01 12:55',   32500),
 ('2022-05-01 12:57',   16000),
 ('2022-05-01 13:42',   17900),
 ('2022-05-01 15:05',   20950),
 ('2022-05-01 15:45',   24700),
 ('2022-05-01 15:49',   18750),
 ('2022-05-01 15:51',   21800)
```

Notice how this data has shows no sales during the business hours of 10am, 2pm, and 4pm.

### Step 2: Traditional GROUP BY Query

First let's try using a `GROUP BY` to aggregate sales per hour:

```sql
DECLARE @Start datetime = '2022-05-01 09:00'
DECLARE @End   datetime = '2022-05-01 17:00'

;WITH SalesAtHourCte AS (
    SELECT
        Total,
        OrderHour = DATEADD(HOUR, DATEDIFF(HOUR, @Start, OrderDateTime), @Start) 
    FROM
        Sales
    WHERE
        OrderDateTime >= @Start AND OrderDateTime <  @End
)
SELECT
    OrderHour,
    HourlySales = SUM(Total)  
FROM
    SalesAtHourCte
GROUP BY
    OrderHour
```

This approach, however, does not account for hours with zero sales.

### Step 3: Incorporating GENERATE_SERIES for Comprehensive Coverage

To ensure every hour within the business day is accounted for, even those without sales, we just use a simple CTE that utilizes `GENERATE_SERIES` to give us one entry for each hour of the business day (9am to 5pm on 5/1/2022, in this example):

```sql
DECLARE @Start datetime = '2022-05-01 09:00'
DECLARE @End   datetime = '2022-05-01 17:00'

;WITH HoursSeriesCte(OrderHour) AS
(
    SELECT
        DATEADD(HOUR, gs.value, @Start)
    FROM
        GENERATE_SERIES(0, DATEDIFF(HOUR, @Start, @End) - 1) AS gs
)
SELECT
    hs.OrderHour,
    HourlySales = COALESCE(SUM(Total),0)
FROM
    HoursSeriesCte AS hs
    LEFT JOIN Sales AS s ON DATE_BUCKET(HOUR, 1, s.OrderDateTime) = hs.OrderHour
GROUP BY
    hs.OrderHour
```

Note how this query joins the hour series produced by the `GENERATE_SERIES` in the `HoursSeriesCte` common table expression on the hourly interval of each row in the `Sales` table using the `DATE_BUCKET` function on the `OrderDateTime` of each sale. By using `LEFT JOIN`, the results include hours from the generated series even if there are no related sales for that hour's bucket.

### Step 4: Cleanup

The `Sales` table is no longer needed, and can now be deleted:

```sql
DROP TABLE Sales
```

___

▶ [Lab: T-SQL Enhancements - TRIM Enhancements](https://github.com/lennilobel/sql2022-workshop-hol/blob/main/HOL/1.%20T-SQL%20Enhancements/6.%20TRIM%20enhancements.md)