# GENERATE_SERIES Function

SQL Server 2022 introduces the `GENERATE_SERIES` function, a powerful tool that simplifies the generation of sequences of numbers, including integer and decimal series, as well as date and time ranges. This function eliminates the need for complex workarounds like recursive CTEs or auxiliary number tables for sequence generation, streamlining data analysis and manipulation tasks.

## Transition from Recursive CTEs to GENERATE_SERIES

**Previous Method: Recursive CTE for Sequence Generation**

```sql
WITH GenerateSeriesCte(value) AS 
(
    SELECT 1 UNION ALL 
    SELECT value + 1 FROM GenerateSeriesCte WHERE value < 1000
)
SELECT value = value FROM GenerateSeriesCte
OPTION (MAXRECURSION 1000)
```

Using recursive CTEs to generate sequences can be verbose and inefficient, especially for larger sequences.

**New Method: Using GENERATE_SERIES**

First, the database compatibility level needs to be set to 160 (SQL Server 2022) to utilize `GENERATE_SERIES`. If you're currently using the `master` database on a SQL Server 2022 instance, then it's compatibility level is already set to 160. But if you are currently using `AdventureWorks2019` from a previous demo, use the `ALTER DATABASE` statement to set the database compatibility level to 160:

```sql
-- Notice the earlier compatibility level on AdventureWorks2019
SELECT compatibility_level FROM sys.databases WHERE name = 'AdventureWorks2019'

-- Raise the 
ALTER DATABASE AdventureWorks2019 SET COMPATIBILITY_LEVEL = 160
```

Now we can use the new GENERATE_SERIES to easily generate a simple range of numbers:

```sql
SELECT value
FROM GENERATE_SERIES(1, 10)
```

Or, create a series with a step value, from 1 to 50, stepping by 5:

```sql
SELECT value
FROM GENERATE_SERIES(1, 50, 5)
```

Or, generating a decimal series from 0.0 to 1.0 with a step of 0.1, using parameterization:

```sql
DECLARE @start decimal(2, 1) = 0.0
DECLARE @stop decimal(2, 1) = 1.0
DECLARE @step decimal(2, 1) = 0.1
    
SELECT value
FROM GENERATE_SERIES(@start, @stop, @step)
```

## Creating a Date Series

This code shows how to generate a series of dates using the `GENERATE_SERIES` function in SQL Server, which natively generates a sequence of numbers. Since `GENERATE_SERIES` does not directly support date generation, the `DATEDIFF` and `DATEADD` functions are employed to achieve this.

```sql
DECLARE @StartOn date = '2023-02-05'
DECLARE @EndOn date = '2023-11-15'
    
DECLARE @DayCount int = DATEDIFF(DAY, @StartOn, @EndOn)
    
SELECT
  TheDate = DATEADD(DAY, value, @StartOn)
FROM
  GENERATE_SERIES(0, @DayCount)
```

This query generates a date series ranging from 2/5/2023 to 11/15/2023 using the following steps:

**1. Determine the Number of Days**: The `DATEDIFF` function calculates the total number of days between two dates, `@StartOn` and `@EndOn`. This duration, stored in `@DayCount`, represents the total number of days to generate in the series.

**2. Generate a Numeric Series**: `GENERATE_SERIES(0, @DayCount)` generates a series of integers starting from 0 up to `@DayCount`. Each number in this series represents an incremental day from the start date.

**3. Convert Numbers to Dates**: For each integer value generated by `GENERATE_SERIES`, the `DATEADD` function adds that value as days to the `@StartOn` date. This effectively converts the numeric series into a series of dates, starting from `@StartOn` and ending on `@EndOn`.

By combining these steps, the code efficiently produces a sequence of dates, one for each day within the specified range. This approach leverages the `GENERATE_SERIES` function's capability to produce a sequence of integers and uses date functions to map those integers to corresponding dates.

## Scenario: Reporting on Sales Data with Unpopulated Intervals

Consider a scenario where sales data is recorded at various times throughout a day, but not every hour is guaranteed to have sales. Traditional aggregation methods like `GROUP BY` might omit hours with no sales, potentially skewing analysis or reporting.

### Step 1: Setup Sales Data Table

First, we create and populate a `Sales` table with sample sales data:

```sql
CREATE TABLE Sales
(
    OrderDateTime    datetime,
    Total            decimal(12,2)
)

-- Populate sales data, where some hours have no sales
INSERT Sales
 (OrderDateTime,        Total) VALUES
 ('2022-05-01 09:35',   21000),
 ('2022-05-01 09:47',   30000),
 ('2022-05-01 11:35',   23000),
 ('2022-05-01 12:55',   32500),
 ('2022-05-01 12:57',   16000),
 ('2022-05-01 13:42',   17900),
 ('2022-05-01 15:05',   20950),
 ('2022-05-01 15:45',   24700),
 ('2022-05-01 15:49',   18750),
 ('2022-05-01 15:51',   21800)
```

Notice how this data has shows no sales during the business hours of 10am, 2pm, and 4pm.

### Step 2: Traditional GROUP BY Query

First let's try using a `GROUP BY` to aggregate sales per hour:

```sql
DECLARE @Start datetime = '2022-05-01 09:00'
DECLARE @End   datetime = '2022-05-01 17:00'

;WITH SalesAtHourCte AS (
    SELECT
        Total,
        OrderHour = DATEADD(HOUR, DATEDIFF(HOUR, @Start, OrderDateTime), @Start) 
    FROM
        Sales
    WHERE
        OrderDateTime >= @Start AND OrderDateTime <  @End
)
SELECT
    OrderHour,
    HourlySales = SUM(Total)  
FROM
    SalesAtHourCte
GROUP BY
    OrderHour
```

This approach, however, does not account for hours with zero sales.

### Step 3: Incorporating GENERATE_SERIES for Comprehensive Coverage

To ensure every hour within the business day is accounted for, even those without sales:

```sql
DECLARE @Start datetime = '2022-05-01 09:00'
DECLARE @End   datetime = '2022-05-01 17:00'

;WITH HoursSeriesCte(OrderHour) AS
(
    SELECT
        DATEADD(HOUR, gs.value, @Start)
    FROM
        GENERATE_SERIES(0, DATEDIFF(HOUR, @Start, @End) - 1) AS gs
)
SELECT
    hs.OrderHour,
    HourlySales = COALESCE(SUM(Total),0)
FROM
    HoursSeriesCte AS hs
    LEFT JOIN Sales AS s ON DATE_BUCKET(HOUR, 1, s.OrderDateTime) = hs.OrderHour
GROUP BY
    hs.OrderHour
```

Note how this query joins the hour series produced by the `GENERATE_SERIES` in the `HoursSeriesCte` common table expression on the hourly interval of each row in the `Sales` table using the `DATE_BUCKET` function on the `OrderDateTime` of each sale. Gy using `LEFT JOIN`, the results include hours from the generated series even if there are no related sales for that hour's bucket.

### Key Takeaways

- **Comprehensive Reporting:** This approach ensures that the report covers every hour within the specified range, displaying zeros for hours without sales, thus providing a complete view of business activity.
- **Efficiency and Simplicity:** `GENERATE_SERIES` simplifies sequence generation, making it more straightforward to create a series of date/time values for interval-based reporting.
- **Enhanced Data Analysis:** By incorporating every hour in the report, businesses gain a clearer understanding of their sales patterns, facilitating better decision-making.

This advanced usage of `GENERATE_SERIES`, combined with `DATE_BUCKET`, showcases SQL Server 2022's capabilities in enhancing data manipulation and reporting tasks, offering a more refined and comprehensive approach to handling temporal data.
